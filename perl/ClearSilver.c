/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2203 from the
 * contents of ClearSilver.xs. Do not edit this file, edit ClearSilver.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "ClearSilver.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "ClearSilver.h"

/* #define DEBUG_MODE 1
 */

typedef struct {
  HDF*      hdf;
  NEOERR* err; 	
} perlHDF; 

typedef struct {
  CSPARSE* cs;
  NEOERR* err;
} perlCS;	

typedef perlHDF* ClearSilver__HDF;
typedef perlCS* ClearSilver__CS;

static char* g_sort_func_name;

static void debug(char* fmt, ...)
{
#ifdef DEBUG_MODE
  va_list argp;
  va_start(argp, fmt);
  vprintf(fmt, argp);
  va_end(argp);
#endif
}

static NEOERR *output (void *ctx, char *s)
{
  sv_catpv((SV*)ctx, s);

  return STATUS_OK;
}

static int sortFunction(const void* in_a, const void* in_b)
{
  HDF** hdf_a;
  HDF** hdf_b;
  perlHDF a, b;
  SV* sv_a;
  SV* sv_b;	
  int count;	
  int ret;

  dSP;

  hdf_a = (HDF**)in_a;
  hdf_b = (HDF**)in_b;

  /* convert to a type Perl can access */
  a.hdf = *hdf_a;
  a.err = STATUS_OK;
  b.hdf = *hdf_b;
  b.err = STATUS_OK;

  ENTER;
  SAVETMPS;

  PUSHMARK(SP);
  sv_a = sv_newmortal();
  sv_setref_pv(sv_a, "ClearSilver::HDF", (void*)&a);

  sv_b = sv_newmortal();
  sv_setref_pv(sv_b, "ClearSilver::HDF", (void*)&b);

  XPUSHs(sv_a);
  XPUSHs(sv_b);

  PUTBACK;

  count = call_pv(g_sort_func_name, G_SCALAR);

  SPAGAIN;

  if (count != 1)
    croak("Big trouble\n");

  PUTBACK;

  ret = POPi;

  FREETMPS;
  LEAVE;

  return ret;
}





#line 109 "ClearSilver.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 161 "ClearSilver.c"

XS(XS_ClearSilver__HDF_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClearSilver__HDF_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	char*	self = (char *)SvPV_nolen(ST(0));
#line 105 "ClearSilver.xs"
	ClearSilver__HDF hdf;
#line 177 "ClearSilver.c"
	ClearSilver__HDF	RETVAL;
#line 107 "ClearSilver.xs"
	debug("%s\n", self);
	hdf = (ClearSilver__HDF)malloc(sizeof(perlHDF));
	if (!hdf) {
	  RETVAL = NULL;
	} else {
	  hdf->err = hdf_init(&(hdf->hdf));
	  RETVAL = hdf;
	}
#line 188 "ClearSilver.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ClearSilver::HDF", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_ClearSilver__HDF_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClearSilver__HDF_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hdf");
    {
	ClearSilver__HDF	hdf;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hdf = INT2PTR(ClearSilver__HDF,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"ClearSilver::HDF::DESTROY",
			"hdf");
#line 122 "ClearSilver.xs"
        debug("hdf_DESTROY:%x\n", hdf);
        hdf_destroy(&(hdf->hdf));
#line 220 "ClearSilver.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_ClearSilver__HDF_setValue); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClearSilver__HDF_setValue)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "hdf, key, value");
    {
	ClearSilver__HDF	hdf;
	char*	key = (char *)SvPV_nolen(ST(1));
	char*	value = (char *)SvPV_nolen(ST(2));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ClearSilver::HDF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hdf = INT2PTR(ClearSilver__HDF,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ClearSilver::HDF::setValue",
			"hdf", "ClearSilver::HDF");
#line 132 "ClearSilver.xs"
        hdf->err = hdf_set_value(hdf->hdf, key, value);
	if (hdf->err == STATUS_OK) {
	    RETVAL = 0;
	} else {
	    RETVAL = 1;
	}	
#line 258 "ClearSilver.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_ClearSilver__HDF_getValue); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClearSilver__HDF_getValue)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "hdf, key, default_value");
    {
	ClearSilver__HDF	hdf;
	char*	key = (char *)SvPV_nolen(ST(1));
	char*	default_value = (char *)SvPV_nolen(ST(2));
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ClearSilver::HDF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hdf = INT2PTR(ClearSilver__HDF,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ClearSilver::HDF::getValue",
			"hdf", "ClearSilver::HDF");
#line 148 "ClearSilver.xs"
        RETVAL = hdf_get_value(hdf->hdf, key, default_value);
#line 292 "ClearSilver.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_ClearSilver__HDF_copy); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClearSilver__HDF_copy)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "hdf, name, src");
    {
	ClearSilver__HDF	hdf;
	char*	name = (char *)SvPV_nolen(ST(1));
	ClearSilver__HDF	src;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ClearSilver::HDF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hdf = INT2PTR(ClearSilver__HDF,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ClearSilver::HDF::copy",
			"hdf", "ClearSilver::HDF");

	if (sv_derived_from(ST(2), "ClearSilver::HDF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    src = INT2PTR(ClearSilver__HDF,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ClearSilver::HDF::copy",
			"src", "ClearSilver::HDF");
#line 159 "ClearSilver.xs"
        hdf->err = hdf_copy(hdf->hdf, name, src->hdf);
        if (hdf->err == STATUS_OK) {
            RETVAL = 0;
        } else {
            RETVAL = 1;
        }
#line 340 "ClearSilver.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_ClearSilver__HDF_readFile); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClearSilver__HDF_readFile)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "hdf, filename");
    {
	ClearSilver__HDF	hdf;
	char*	filename = (char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ClearSilver::HDF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hdf = INT2PTR(ClearSilver__HDF,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ClearSilver::HDF::readFile",
			"hdf", "ClearSilver::HDF");
#line 173 "ClearSilver.xs"
        hdf->err = hdf_read_file(hdf->hdf, filename);
	if (hdf->err == STATUS_OK) {
	    RETVAL = 1;
	} else {
	    RETVAL = 0;
	}	
#line 378 "ClearSilver.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_ClearSilver__HDF_writeFile); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClearSilver__HDF_writeFile)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "hdf, filename");
    {
	ClearSilver__HDF	hdf;
	char*	filename = (char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ClearSilver::HDF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hdf = INT2PTR(ClearSilver__HDF,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ClearSilver::HDF::writeFile",
			"hdf", "ClearSilver::HDF");
#line 187 "ClearSilver.xs"
        hdf->err = hdf_write_file(hdf->hdf, filename);
       if (hdf->err == STATUS_OK) {
           RETVAL = 1;
       } else {
           RETVAL = 0;
       }
#line 416 "ClearSilver.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_ClearSilver__HDF_getObj); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClearSilver__HDF_getObj)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "hdf, name");
    {
	ClearSilver__HDF	hdf;
	char*	name = (char *)SvPV_nolen(ST(1));
#line 201 "ClearSilver.xs"
	HDF* tmp_hdf;
	perlHDF* perlhdf;
#line 439 "ClearSilver.c"
	ClearSilver__HDF	RETVAL;

	if (sv_derived_from(ST(0), "ClearSilver::HDF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hdf = INT2PTR(ClearSilver__HDF,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ClearSilver::HDF::getObj",
			"hdf", "ClearSilver::HDF");
#line 204 "ClearSilver.xs"
	do {
	    tmp_hdf = hdf_get_obj(hdf->hdf, name);
	    if (!tmp_hdf) {
	        RETVAL = NULL;
		break;
	    }
	    perlhdf = (perlHDF*)malloc(sizeof(perlHDF));
	    if (!perlhdf) {
	        RETVAL = NULL;
	        break;
	    }
            perlhdf->hdf = tmp_hdf;
	    perlhdf->err = STATUS_OK;
	    RETVAL = perlhdf;
	} while (0);
#line 466 "ClearSilver.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ClearSilver::HDF", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_ClearSilver__HDF_objChild); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClearSilver__HDF_objChild)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hdf");
    {
	ClearSilver__HDF	hdf;
#line 226 "ClearSilver.xs"
	HDF* tmp_hdf;
	perlHDF* child;
#line 489 "ClearSilver.c"
	ClearSilver__HDF	RETVAL;

	if (sv_derived_from(ST(0), "ClearSilver::HDF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hdf = INT2PTR(ClearSilver__HDF,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ClearSilver::HDF::objChild",
			"hdf", "ClearSilver::HDF");
#line 229 "ClearSilver.xs"
	do {
	    tmp_hdf = hdf_obj_child(hdf->hdf);
	    if (!tmp_hdf) {
	        RETVAL = NULL;
		break;
	    }
	    child = (perlHDF*)malloc(sizeof(perlHDF));
	    if (!child) {
	        RETVAL = NULL;
	        break;
	    }
            child->hdf = tmp_hdf;
	    child->err = STATUS_OK;
	    RETVAL = child;
	} while (0);
#line 516 "ClearSilver.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ClearSilver::HDF", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_ClearSilver__HDF_getChild); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClearSilver__HDF_getChild)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "hdf, name");
    {
	ClearSilver__HDF	hdf;
	char*	name = (char *)SvPV_nolen(ST(1));
#line 253 "ClearSilver.xs"
	HDF* tmp_hdf;
	perlHDF* child;
#line 540 "ClearSilver.c"
	ClearSilver__HDF	RETVAL;

	if (sv_derived_from(ST(0), "ClearSilver::HDF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hdf = INT2PTR(ClearSilver__HDF,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ClearSilver::HDF::getChild",
			"hdf", "ClearSilver::HDF");
#line 256 "ClearSilver.xs"
	do {
	    tmp_hdf = hdf_get_child(hdf->hdf, name);
	    if (!tmp_hdf) {
	        RETVAL = NULL;
		break;
	    }
	    child = (perlHDF*)malloc(sizeof(perlHDF));
	    if (!child) {
	        RETVAL = NULL;
	        break;
	    }
            child->hdf = tmp_hdf;
	    child->err = STATUS_OK;
	    RETVAL = child;
	} while (0);
#line 567 "ClearSilver.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ClearSilver::HDF", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_ClearSilver__HDF_objValue); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClearSilver__HDF_objValue)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hdf");
    {
	ClearSilver__HDF	hdf;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ClearSilver::HDF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hdf = INT2PTR(ClearSilver__HDF,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ClearSilver::HDF::objValue",
			"hdf", "ClearSilver::HDF");
#line 278 "ClearSilver.xs"
	RETVAL = hdf_obj_value(hdf->hdf);
#line 600 "ClearSilver.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_ClearSilver__HDF_objName); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClearSilver__HDF_objName)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hdf");
    {
	ClearSilver__HDF	hdf;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ClearSilver::HDF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hdf = INT2PTR(ClearSilver__HDF,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ClearSilver::HDF::objName",
			"hdf", "ClearSilver::HDF");
#line 286 "ClearSilver.xs"
	RETVAL = hdf_obj_name(hdf->hdf);
#line 632 "ClearSilver.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_ClearSilver__HDF_objNext); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClearSilver__HDF_objNext)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "hdf");
    {
	ClearSilver__HDF	hdf;
#line 294 "ClearSilver.xs"
	HDF* tmp_hdf;
	perlHDF* next;
#line 654 "ClearSilver.c"
	ClearSilver__HDF	RETVAL;

	if (sv_derived_from(ST(0), "ClearSilver::HDF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hdf = INT2PTR(ClearSilver__HDF,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ClearSilver::HDF::objNext",
			"hdf", "ClearSilver::HDF");
#line 297 "ClearSilver.xs"
	do {
	    tmp_hdf = hdf_obj_next(hdf->hdf);
	    if (!tmp_hdf) {
	        RETVAL = NULL;
		break;
	    }
	    next = (perlHDF*)malloc(sizeof(perlHDF));
	    if (!next) {
	      RETVAL = NULL;
	      break;
            }
	    next->hdf = tmp_hdf;
	    next->err = STATUS_OK;
	    RETVAL = next;
	} while (0);
#line 681 "ClearSilver.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ClearSilver::HDF", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_ClearSilver__HDF_sortObj); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClearSilver__HDF_sortObj)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "hdf, func_name");
    {
	ClearSilver__HDF	hdf;
	char*	func_name = (char *)SvPV_nolen(ST(1));
#line 320 "ClearSilver.xs"
        NEOERR* err;
#line 704 "ClearSilver.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ClearSilver::HDF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hdf = INT2PTR(ClearSilver__HDF,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ClearSilver::HDF::sortObj",
			"hdf", "ClearSilver::HDF");
#line 322 "ClearSilver.xs"
	g_sort_func_name = func_name;
        err = hdf_sort_obj(hdf->hdf, sortFunction);
        RETVAL = 0;
#line 720 "ClearSilver.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_ClearSilver__HDF_setSymlink); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClearSilver__HDF_setSymlink)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "hdf, src, dest");
    {
	ClearSilver__HDF	hdf;
	char*	src = (char *)SvPV_nolen(ST(1));
	char*	dest = (char *)SvPV_nolen(ST(2));
#line 335 "ClearSilver.xs"
	NEOERR* err;
#line 743 "ClearSilver.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ClearSilver::HDF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hdf = INT2PTR(ClearSilver__HDF,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ClearSilver::HDF::setSymlink",
			"hdf", "ClearSilver::HDF");
#line 337 "ClearSilver.xs"
      	err = hdf_set_symlink (hdf->hdf, src, dest);
       	if (err == STATUS_OK) {
       	    RETVAL = 1;
       	} else {
       	    RETVAL = 0;
       	}
#line 762 "ClearSilver.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_ClearSilver__HDF_removeTree); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClearSilver__HDF_removeTree)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "hdf, name");
    {
	ClearSilver__HDF	hdf;
	char*	name = (char *)SvPV_nolen(ST(1));
#line 352 "ClearSilver.xs"
        NEOERR* err;
#line 784 "ClearSilver.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ClearSilver::HDF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hdf = INT2PTR(ClearSilver__HDF,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ClearSilver::HDF::removeTree",
			"hdf", "ClearSilver::HDF");
#line 354 "ClearSilver.xs"
        err = hdf_remove_tree(hdf->hdf, name);
       	if (err == STATUS_OK) {
       	    RETVAL = 1;
       	} else {
       	    RETVAL = 0;
       	}
#line 803 "ClearSilver.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_ClearSilver__CS_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClearSilver__CS_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, hdf");
    {
	char*	self = (char *)SvPV_nolen(ST(0));
	ClearSilver__HDF	hdf;
#line 371 "ClearSilver.xs"
        perlCS* cs;
#line 825 "ClearSilver.c"
	ClearSilver__CS	RETVAL;

	if (sv_derived_from(ST(1), "ClearSilver::HDF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    hdf = INT2PTR(ClearSilver__HDF,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ClearSilver::CS::new",
			"hdf", "ClearSilver::HDF");
#line 373 "ClearSilver.xs"
	cs = (perlCS*)malloc(sizeof(perlCS));
	if (!cs) {
	  RETVAL = NULL;
	} else {
	  cs->err = cs_init(&(cs->cs), hdf->hdf);
	  if (cs->err == STATUS_OK) {
	    cs->err = cgi_register_strfuncs(cs->cs);
	  }
	  RETVAL = cs;
	}
#line 847 "ClearSilver.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ClearSilver::CS", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_ClearSilver__CS_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClearSilver__CS_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cs");
    {
	ClearSilver__CS	cs;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cs = INT2PTR(ClearSilver__CS,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"ClearSilver::CS::DESTROY",
			"cs");
#line 390 "ClearSilver.xs"
	debug("perlcs_DESTROY() is called\n");
	cs_destroy(&(cs->cs));
#line 879 "ClearSilver.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_ClearSilver__CS_displayError); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClearSilver__CS_displayError)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cs");
    {
	ClearSilver__CS	cs;

	if (sv_derived_from(ST(0), "ClearSilver::CS")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cs = INT2PTR(ClearSilver__CS,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ClearSilver::CS::displayError",
			"cs", "ClearSilver::CS");
#line 397 "ClearSilver.xs"
	nerr_log_error(cs->err);
#line 908 "ClearSilver.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_ClearSilver__CS_render); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClearSilver__CS_render)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cs");
    {
	ClearSilver__CS	cs;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ClearSilver::CS")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cs = INT2PTR(ClearSilver__CS,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ClearSilver::CS::render",
			"cs", "ClearSilver::CS");
#line 403 "ClearSilver.xs"
    {
	SV *str = newSV(0);
	cs->err = cs_render(cs->cs, str, output);
	if (cs->err == STATUS_OK) {
	  ST(0) = sv_2mortal(str);
	} else {
	  SvREFCNT_dec(str);
	  ST(0) = &PL_sv_undef;
	}
	XSRETURN(1);
    }
#line 949 "ClearSilver.c"
    }
    XSRETURN(1);
}


XS(XS_ClearSilver__CS_parseFile); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClearSilver__CS_parseFile)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "cs, cs_file");
    {
	ClearSilver__CS	cs;
	char*	cs_file = (char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ClearSilver::CS")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cs = INT2PTR(ClearSilver__CS,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ClearSilver::CS::parseFile",
			"cs", "ClearSilver::CS");
#line 420 "ClearSilver.xs"
	do {
	    cs->err =  cs_parse_file(cs->cs, cs_file);
	    if (cs->err != STATUS_OK) {
	        cs->err = nerr_pass(cs->err);
		RETVAL = 0;
		break;
	    }
	    RETVAL = 1;
        } while (0);
#line 989 "ClearSilver.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_ClearSilver__CS_parseString); /* prototype to pass -Wmissing-prototypes */
XS(XS_ClearSilver__CS_parseString)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "cs, in_str");
    {
	ClearSilver__CS	cs;
	char*	in_str = (char *)SvPV_nolen(ST(1));
#line 437 "ClearSilver.xs"
	char* cs_str;
	int len;
#line 1012 "ClearSilver.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ClearSilver::CS")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cs = INT2PTR(ClearSilver__CS,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ClearSilver::CS::parseString",
			"cs", "ClearSilver::CS");
#line 440 "ClearSilver.xs"
	do {
	    len = strlen(in_str);
	    cs_str = (char *)malloc(len);
	    if (!cs_str) {
	        RETVAL = 0;
		break;
	    }
	    strcpy(cs_str, in_str);
            cs->err =  cs_parse_string(cs->cs, cs_str, len);
	    if (cs->err != STATUS_OK)
		RETVAL = 0;
	    RETVAL = 1;
       } while (0);
#line 1038 "ClearSilver.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_ClearSilver); /* prototype to pass -Wmissing-prototypes */
XS(boot_ClearSilver)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXS("ClearSilver::HDF::new", XS_ClearSilver__HDF_new, file);
        newXS("ClearSilver::HDF::DESTROY", XS_ClearSilver__HDF_DESTROY, file);
        newXS("ClearSilver::HDF::setValue", XS_ClearSilver__HDF_setValue, file);
        newXS("ClearSilver::HDF::getValue", XS_ClearSilver__HDF_getValue, file);
        newXS("ClearSilver::HDF::copy", XS_ClearSilver__HDF_copy, file);
        newXS("ClearSilver::HDF::readFile", XS_ClearSilver__HDF_readFile, file);
        newXS("ClearSilver::HDF::writeFile", XS_ClearSilver__HDF_writeFile, file);
        newXS("ClearSilver::HDF::getObj", XS_ClearSilver__HDF_getObj, file);
        newXS("ClearSilver::HDF::objChild", XS_ClearSilver__HDF_objChild, file);
        newXS("ClearSilver::HDF::getChild", XS_ClearSilver__HDF_getChild, file);
        newXS("ClearSilver::HDF::objValue", XS_ClearSilver__HDF_objValue, file);
        newXS("ClearSilver::HDF::objName", XS_ClearSilver__HDF_objName, file);
        newXS("ClearSilver::HDF::objNext", XS_ClearSilver__HDF_objNext, file);
        newXS("ClearSilver::HDF::sortObj", XS_ClearSilver__HDF_sortObj, file);
        newXS("ClearSilver::HDF::setSymlink", XS_ClearSilver__HDF_setSymlink, file);
        newXS("ClearSilver::HDF::removeTree", XS_ClearSilver__HDF_removeTree, file);
        newXS("ClearSilver::CS::new", XS_ClearSilver__CS_new, file);
        newXS("ClearSilver::CS::DESTROY", XS_ClearSilver__CS_DESTROY, file);
        newXS("ClearSilver::CS::displayError", XS_ClearSilver__CS_displayError, file);
        newXS("ClearSilver::CS::render", XS_ClearSilver__CS_render, file);
        newXS("ClearSilver::CS::parseFile", XS_ClearSilver__CS_parseFile, file);
        newXS("ClearSilver::CS::parseString", XS_ClearSilver__CS_parseString, file);
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

